1. Ссылки
   1. [50 оттенков Go: ловушки, подводные камни и распространённые ошибки новичков](https://habr.com/ru/companies/vk/articles/314804/)
   2. [Нотации структур](https://www.digitalocean.com/community/tutorials/how-to-use-struct-tags-in-go-ru)
   3. [Плигин для генерации структуры из sql/json](https://github.com/liuhao2050/to-go-struct-intellij-plugin)
2. [Команды go](https://pkg.go.dev/cmd/go)
   1. generate - generate Go files by processing source. По сути разработка выглядит так: Находим готовые либы/бинарники(например enumer) для кодогенерации, пишем код для скармливания этим либам, прогоняем либы запуском команды go generate ./file_path (в самом файле вверху указываем директиву //go:generate enumer ) и генерируем необходимый код, пишем основной высокоуровнеывый код, который использует, в том числе кодосгенерированный
3. Топ ключевых слов
   1. var
   2. const
      1.  iota - встроенный генератор последовательностей. Можно указать `const (ConstA = iota // = 0 ConstB = iotA // = 1)` или в сокращенном виде`const (ConstA = iota // = 0 ConstB // = 1)`
      2. Если добавить еще [enumer](https://github.com/dmarkham/enumer) то можно получить очень удобную работу с enum-значениями из базы
   3. type
   4. func
   5. package, import
   6. if, switch, for _,x; := [range] slice
4. Публичность на уровне пакета констант, методов и структур определяется по первой букве. myConst - приватная константа, MyConst - публичная
5. Слайс - контейнер, каждый элемент которого является указателем на определенный элемент массива, причем последовательность элементов является интервалом массива. 
   1. `var arrayVar [5]int` - массив с пятью нулевыми интами
   2. `var arrayVar [5]int{1,2,3}` - массив с указанными по умолчанию первыми тремя элементами
   3. `var sliceNil []int` - пустой слайс(а не пустой массив!) равный nil(пустой массив объявить нельзя да и незачем)
   4. `var sliceVar = arrayVar[1:3]` слайс содержащий указатели на 1 и 2 элементы массива. нулевой, третий и четвертый элементы включены не будут.
   5. `var sliceMake = make([]int, 5)` - создает пустой массив с пятью элементами, а затем возвращает слайс на него. Более предпочтительный способ создания слайса.
   6. `len(sliceVar)` - количество элементов, которые содержит срез или массив
   7. `cap(sliceVar)` - количество элементов в базовом массиве, считая от ПЕРВОГО элемента В СРЕЗЕ.
   8. `sliceAppend = append(sliceNil, 0)` - добавит еще один элемент в конец со значением 0
   9. `for i, v := range sliceVar {}` - перебор для слайсов или мап. В связке с оператором for является аналогом foreach php. Первое значение индекс, второе копия элемента под этим индексом. если индекс или элемент не нужен можно проставлять прочерки _ вместо имен переменных `for _, v := range sliceVar {}`
   10. `mapVar := map[string]int{"abc": 2}` - мапа с ассоциативными ключами. Важно. Перед заполнением мапы ее нужно объявить(выделить место в памяти). При указании типа переменной, например `var a map[string]int` инициализации не происходит. Можно использовать либо как указано вначале, либо через `make(map[string]int)`. Иначе получим `panic: assignment to entry in nil map`
6. Ключевое слово **type** - определяет некий аналог класса. С помощью него можно задать название и указать его тип, структура или алиас на базовый тип(инт, стринг). После чего к этому типу можно добавлять методы
   1. Может являться алиасом на базовый тип(например как встроенные алиасы rune, byte, any)
   2. Часто используется для объявления структуры struct `type Vertex struct {
      X, Y float64
      }` для переиспользования в коде
   3. Часто используется для объявления интерфейсов `type Abser interface {
      Abs() float64
      }` в переменные этого типа можно записать только типы, имеющие указанный метод. Можно указывать пустой интерфейс `var i interface{}`
7. Метод - это таже функция, только привязанная к определенному типу, то есть имеет получателя (receiver). Например `func (v Vertex) Abs() float64` тип перед названием функции и есть получатель, внутри этой функции можно обратиться к полям этого получателя. А вот запись `func Abs(v Vertex) float64` обозначает просто функцию, которая принимает на вход тип Vertex. Методы можно объявлять только к типам, указанным в текущем пакете (package)
   1. Можно привязывать методы к указателям типов, в этом случае мы получаем аналог работы с указателем $this в php. Таким образом можем изменять значения указанного типа не выходя из метода
   2. В случае привязке к указателю можно метод будет работать как с самим типом так и с указателем на него https://go.dev/tour/methods/6
8. Проверка типов (Type assertions). 
   1. Чтобы проверить принадлежность переменной к определенному типу достаточно воспользоваться `t, ok := i.(T)` в случае если i(пустой интерфейс с заданным значением по умолчанию) не соответствует указанному типу T то в t будет пустое значение исходного типа а в ok будет false; если не указать ok в объявлении вылетит panic. Не интерфейсы можно тоже преобразовывать, используя название типа как функцию, но тогда выйдет ошибка компиляции `float64(int)`. Эта запись так же подходит для проверки на существование ключа в мэпе `if _,ok := x["two"]; !ok {}` 
   2. Есть проверка типов в switch https://go.dev/tour/methods/16. 
   3. Узнать текущий тип можно через `reflect.TypeOf(Var)`. 
   4. Привести к определенному типу можно с помощью использования названия типа как функции, например int(foo). Такой способ хорошо подходит для похожих типов, например числовых типов из int8 в int16(в большую разрядность). Преобразовать таким образом число в строку не получится, необходимо использовать спец.пакеты, например strconv или `fmt.Sprintf()`
9. Основные интерфейсы 
   1. Stringers - интерфейс, определенный в fmt. содержит метод String(), который вызывается например до вывода на печать: https://go.dev/tour/methods/17
   2. error - интерфейс, определенный в builtin. Содержит метод Error() обозначающий ошибку. Нужен для обработки ошибок 
   3. Reader - интерфейс, определенный в io. Содержит метод Read() генерирующий потоковую выдачу данных в передаваемый в него слайс байтов, Например юникод символы. 
   4. Image - интерфейс, определенный в image.go. Содержит методы ColorModel(), Bounds(), At() необходимые для полноценной работы с изображением...
10. Основные пакеты
    1. builtin - содержит описание базовых типов языка и методов
    2. context. Его одноименный интерфейс имеет описание происходящего в текущем потоке. Имеет методы Deadline(), Done(), Err(), Value(). При запуске любой программы автоматически создается контекст бэкграунд context.Background() самый верхнеуровневый контекст
       1. При работе с базой лучше всего работать с дочерним контекстом context.WithCancel(context.Background()) и defer cancel(). Чтобы разрывать соединение с базой и освобождать ресурсы
    3. io
    4. os - может работать в том числе с сигналами от операционной системы
    4. testing
    5. time
    6. sync
    7. strings
    8. strconv
    9. sort
    10. reflect
    11. math
    12. fmt
    13. database
11. Generics. Используются в функциях через ключевое слово comparable например `func Index[T comparable](s []T, x T){}`, так же можно объявить через алиас к интерфейсам any `type List[T any] struct {}`
12. Многозадачность / Конкурентный код / concurrency
    1. goroutine - легковесный поток, который управляется планировщиком горутин, который сопоставляет горутину, поток ОС и ресурсы выполнения  
13. Сущность к которой обращаются через точку и дальше идет callable-строка со скобками require.Empty(), может быть:
    1. Кастомным типом, к которому добавили метод 
    2. Пакетом, внутри которого описана эта функция
14. Тестирование. Тесты запускаются командой go test ./... (запуск всех тестов в проекте, или можно указать конкретный путь до пакета). Тесты определяются наличием суффикса _test в названии файла и префикса Test_ в названии функции. При запуске команды проект парситься на наличие этих файлов и функций. Тесты размещают в том же пакете для доступа к приватным методам 
    1. Тесты с моками
       1. [sql-mock](https://github.com/DATA-DOG/go-sqlmock)
    2. Интеграционные тесты
15. Структура папок
    1. Создает неймспейсы проектов. В разных папках не могут находится файлы одного и того же проекта
    2. папка internal ограничивает доступ к коду внутри
    3. папка testdata зарезервирована под фикстуры, тестовые json, картинки